/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package v1

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.subcommands
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.multiple
import com.github.ajalt.clikt.parameters.types.int
import java.lang.Integer.sum
import java.time.ZonedDateTime
import kotlin.random.Random

class App : CliktCommand() {
	override fun run() {}

	companion object {
		/**
		 * Return true if this is a valid n-queens solution
		 */
		private fun checkBoard(board: List<Int>): Boolean {
			TODO("Your mother")
		}

		enum class PrintOptions {
			SLIM,
			FULL
		}

		/**
		 * Nicely prints the board
		 */
		private fun printBoard(board: List<Int>, printAs: PrintOptions = PrintOptions.SLIM) {
			when (printAs) {
				PrintOptions.SLIM -> {
					TODO("Print the board as a list of row offsets, machine friendly (each has plus 1 to align with hackerrank format)")
				}
				PrintOptions.FULL -> {
					TODO("Print the board as a grid of chess positions that are empty or queens, more human friendly until the board gets huge")
				}
			}
		}
	}

	class CheckSubCommand : CliktCommand(
		name = "check"
	) {
		val boardList: List<Int> by argument().int().multiple(required = true)
		override fun run() {
			println("checking...")
		}
	}

	class SolveSubCommand : CliktCommand(
		name = "solve"
	) {

		val size by argument(help = "The sizeÂ² of the board").int()

		private val random = Random(ZonedDateTime.now().toEpochSecond())

		private val globalSlopeCache: HashMap<SlopeIntercept, Set<HashmapEntry>> = hashMapOf()

		/**
		 * A list of row offsets for every column
		 */
		private val board: List<Int> = listOf()

		private fun countAllConflicts(): Int {
			return (0 until size).sumOf { column ->
				countConflicts(column)
			}
		}

		/**
		 * Place a piece at row: [row] and column: [col]
		 */
		private fun placePiece(row: Int, column: Int) {
			// loop for every column that isn't the working column
			for (otherColumn in 0 until size) {
				// Skip this column if its the same as the passed in column
				if (otherColumn == column) continue

				// Get slope intercept of looped point and passed in point
				var slopeIntercept = Util.getSlopeInterceptObject(
							Point(board[otherColumn], otherColumn),
							Point(board[column], column)
						)
				if (globalSlopeCache[slopeIntercept]) {
					globalSlopeCache[slopeIntercept].count++
				}
				else {
					globalSlopeCache[slopeIntercept] = HashmapEntry(0)
				}
			}
			// Modify global slopes, replace any instances that included this column with the new values
		}


		private fun countConflicts(column: Int): Int {
			var conflictCount = 0
			// loop for every column that isn't the working column
			for (otherColumn in 0 until size) {
				// Skip this column if its the same as the passed in column
				if (otherColumn == column) continue

				// Get slope intercept of looped point and passed in point
				globalSlopeCache[
						Util.getSlopeInterceptObject(
							Point(board[otherColumn], otherColumn),
							Point(board[column], column)
						)
				]?.let { conflictCount++ }
			}
			return conflictCount
		}

		/**
		 * Count the total conflicts for every row in [column]
		 */
		private fun countConflictsInColumn(column: Int): List<Int> {
			return (0 until size).map { row ->
				var conflictCount = 0

				for (otherColumn in 0 until size) {
					// Skip this column if its the same
					if (otherColumn == column) continue

					// Get slope intercept
					globalSlopeCache[
							Util.getSlopeInterceptObject(
								Point(board[otherColumn], otherColumn),
								Point(row, otherColumn)
							)
					]?.let { conflictCount++ }
				}

				return@map conflictCount
			}
		}

		private fun selectBestRow(conflicts: List<Int>): Int {
			return conflicts.withIndex()
				.sortedBy { it.value } // The value is a # of conflicts
				.let { sortedList ->
					sortedList.filter { it.value == sortedList[0].value }
				}
				.random(random)
				.index // This is a row
		}

		override fun run() {
			// loop until solved then break
			while (true) {
				repeat(1000) {
					val col: Int = random.nextInt(size)
					val listOfRowConflictCount: List<Int> = countConflictsInColumn(col)

					placePiece(selectBestRow(listOfRowConflictCount), col)
					if (checkBoard(board)) {
						printBoard(board)
						return
					}
				}
			}
		}
	}
}

fun main(args: Array<String>) = App().subcommands(App.SolveSubCommand(), App.CheckSubCommand()).main(args)
